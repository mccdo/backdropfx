
BDFX INCLUDE shaders/gl2/ffp-declarations.common
BDFX INCLUDE shaders/gl2/ffp-declarations.vs

// Copyright (c) 2010 Skew Matrix Software. All rights reserved.
// gl2/ffp-lighting-utilities.common


vec4 internalAmbientDiffuse( out float diffuseDot, inout vec4 pli,
    in vec4 Acm, in vec4 Dcm, in vec4 Alight, in vec4 Dlight )
{
    if( pli.w != 0. )
        pli -= bdfx_eyeVertex;
    pli.xyz = normalize( pli.xyz );
    diffuseDot = max( dot( bdfx_eyeNormal, pli.xyz ), 0.0 );

    vec3 color = ( ( Acm.rgb * Alight.rgb ) + ( diffuseDot * Dcm.rgb * Dlight.rgb ) );
    return( vec4( color, Dcm.a ) );
}

vec4 internalDiffuse( out float diffuseDot, inout vec4 pli,
    in vec4 Dcm, in vec4 Dlight )
{
    if( pli.w != 0. )
        pli -= bdfx_eyeVertex;
    pli.xyz = normalize( pli.xyz );
    diffuseDot = max( dot( bdfx_eyeNormal, pli.xyz ), 0.0 );

    vec3 color = ( diffuseDot * Dcm.rgb * Dlight.rgb );
    return( vec4( color, Dcm.a ) );
}

vec4 internalSpecular( in vec3 pli, in vec4 Slight )
{
    // local viewer == FALSE
    vec3 hi = normalize( pli + vec3( 0., 0., 1. ) );
    if( bdfx_lightModel.localViewer == 1 )
    {
        vec3 VPe = -vec3( bdfx_modelViewMatrix * bdfx_vertex );
        hi = normalize( pli + VPe );
    }
    float specularDot = max( dot( bdfx_eyeNormal, hi ), 0.0 );
    
    vec3 color = ( pow( specularDot, bdfx_frontMaterial.shininess ) *
        bdfx_frontMaterial.specular.rgb * Slight.rgb );
    return( vec4( color, 0. ) );
}

// END gl2/ffp-lighting-utilities.common

